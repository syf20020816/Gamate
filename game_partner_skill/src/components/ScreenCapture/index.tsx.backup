import { useState, useRef, useEffect } from "react";
import { Card, Button, Space, Typography, Divider, Select, message, Slider } from "antd";
import { Monitor, Play, Square, Scissors, Download, RefreshCw } from "lucide-react";
import { motion } from "framer-motion";
import { invoke } from "@tauri-apps/api/core";
import "./styles.scss";

const { Title, Text, Paragraph } = Typography;

interface CaptureArea {
  x: number;
  y: number;
  width: number;
  height: number;
}

interface DisplayInfo {
  id: number;
  name: string;
  width: number;
  height: number;
  is_primary: boolean;
}

interface Screenshot {
  data: string; // Base64 PNG
  width: number;
  height: number;
  timestamp: number;
  display_id: number | null;
  mode: string;
}

const ScreenCapture: React.FC = () => {
  const [isCapturing, setIsCapturing] = useState(false);
  const [captureMode, setCaptureMode] = useState<"fullscreen" | "window" | "area">("fullscreen");
  const [captureArea, setCaptureArea] = useState<CaptureArea | null>(null);
  const [isDragging, setIsDragging] = useState(false);
  const [fps, setFps] = useState(30);
  const [displays, setDisplays] = useState<DisplayInfo[]>([]);
  const [selectedDisplay, setSelectedDisplay] = useState<number>(0);
  const [currentScreenshot, setCurrentScreenshot] = useState<string | null>(null);
  const [captureInterval, setCaptureInterval] = useState<NodeJS.Timeout | null>(null);
  const canvasRef = useRef<HTMLDivElement>(null);

  // 加载显示器列表
  useEffect(() => {
    loadDisplays();
  }, []);

  const loadDisplays = async () => {
    try {
      const displayList = await invoke<DisplayInfo[]>("list_displays");
      setDisplays(displayList);
      if (displayList.length > 0) {
        setSelectedDisplay(displayList[0].id);
      }
    } catch (error) {
      console.error("获取显示器列表失败:", error);
      message.error("获取显示器列表失败");
    }
  };

  const captureScreenshot = async () => {
    try {
      let screenshot: Screenshot;

      if (captureMode === "fullscreen") {
        screenshot = await invoke<Screenshot>("capture_fullscreen", {
          displayId: selectedDisplay,
        });
      } else if (captureMode === "area" && captureArea) {
        screenshot = await invoke<Screenshot>("capture_area", {
          area: {
            x: Math.round(captureArea.x),
            y: Math.round(captureArea.y),
            width: Math.round(Math.abs(captureArea.width)),
            height: Math.round(Math.abs(captureArea.height)),
          },
          displayId: selectedDisplay,
        });
      } else {
        return;
      }

      setCurrentScreenshot(screenshot.data);
    } catch (error) {
      console.error("截图失败:", error);
      message.error(`截图失败: ${error}`);
    }
  };

  const handleStartCapture = async () => {
    try {
      setIsCapturing(true);
      message.success("开始截屏识别");

      // 立即截取一次
      await captureScreenshot();

      // 设置定时截图
      const interval = setInterval(() => {
        captureScreenshot();
      }, 1000 / fps);

      setCaptureInterval(interval);
    } catch (error) {
      message.error("启动失败");
      setIsCapturing(false);
    }
  };

  const handleStopCapture = () => {
    if (captureInterval) {
      clearInterval(captureInterval);
      setCaptureInterval(null);
    }
    setIsCapturing(false);
    message.info("已停止截屏");
  };

  const handleRefresh = async () => {
    if (isCapturing) {
      await captureScreenshot();
    }
  };

  const handleSaveScreenshot = () => {
    if (!currentScreenshot) {
      message.warning("没有可保存的截图");
      return;
    }

    // 创建下载链接
    const link = document.createElement("a");
    link.href = currentScreenshot;
    link.download = `screenshot_${Date.now()}.png`;
    link.click();
    message.success("截图已保存");
  };

  const handleSelectArea = () => {
    message.info("请在预览区域拖拽选择截屏范围");
    // TODO: 实现拖拽选择逻辑
  };

  const handleMouseDown = (e: React.MouseEvent) => {
    if (captureMode !== "area") return;
    setIsDragging(true);
    const rect = canvasRef.current?.getBoundingClientRect();
    if (rect) {
      setCaptureArea({
        x: e.clientX - rect.left,
        y: e.clientY - rect.top,
        width: 0,
        height: 0,
      });
    }
  };

  const handleMouseMove = (e: React.MouseEvent) => {
    if (!isDragging || !captureArea) return;
    const rect = canvasRef.current?.getBoundingClientRect();
    if (rect) {
      setCaptureArea({
        ...captureArea,
        width: e.clientX - rect.left - captureArea.x,
        height: e.clientY - rect.top - captureArea.y,
      });
    }
  };

  const handleMouseUp = () => {
    setIsDragging(false);
    if (captureArea && (captureArea.width !== 0 || captureArea.height !== 0)) {
      message.success(`已选择区域: ${Math.abs(captureArea.width)}x${Math.abs(captureArea.height)}`);
    }
  };

  return (
    <div className="screen-capture">
      <motion.div
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.3 }}
      >
        <Card className="control-panel">
          <Space direction="vertical" size="large" style={{ width: "100%" }}>
            <div>
              <Title level={4}>
                <Monitor size={24} style={{ marginRight: 8 }} />
                屏幕识别设置
              </Title>
              <Paragraph type="secondary">
                配置截屏模式和识别参数,实时捕获游戏画面
              </Paragraph>
            </div>

            <Divider />

            {/* 捕获模式选择 */}
            <div className="control-item">
              <Text strong>捕获模式</Text>
              <Select
                value={captureMode}
                onChange={setCaptureMode}
                style={{ width: "100%", marginTop: 8 }}
                disabled={isCapturing}
                options={[
                  { label: "全屏捕获", value: "fullscreen" },
                  { label: "窗口捕获", value: "window", disabled: true },
                  { label: "区域捕获", value: "area" },
                ]}
              />
            </div>

            {/* 显示器选择 */}
            {displays.length > 1 && (
              <div className="control-item">
                <Text strong>显示器</Text>
                <Select
                  value={selectedDisplay}
                  onChange={setSelectedDisplay}
                  style={{ width: "100%", marginTop: 8 }}
                  disabled={isCapturing}
                  options={displays.map((d) => ({
                    label: `${d.name} (${d.width}x${d.height})${d.is_primary ? " - 主屏" : ""}`,
                    value: d.id,
                  }))}
                />
              </div>
            )}

            {/* FPS 设置 */}
            <div className="control-item">
              <Space style={{ width: "100%", justifyContent: "space-between" }}>
                <Text strong>帧率 (FPS)</Text>
                <Text type="secondary">{fps} fps</Text>
              </Space>
              <Slider
                min={10}
                max={60}
                value={fps}
                onChange={setFps}
                marks={{ 10: "10", 30: "30", 60: "60" }}
                style={{ marginTop: 8 }}
              />
            </div>

            {/* 操作按钮 */}
            <Space size="middle" style={{ width: "100%" }}>
              {!isCapturing ? (
                <Button
                  type="primary"
                  icon={<Play size={18} />}
                  onClick={handleStartCapture}
                  size="large"
                  block
                >
                  开始识别
                </Button>
              ) : (
                <Button
                  danger
                  icon={<Square size={18} />}
                  onClick={handleStopCapture}
                  size="large"
                  block
                >
                  停止识别
                </Button>
              )}
            </Space>

            {captureMode === "area" && (
              <Button
                icon={<Scissors size={18} />}
                onClick={handleSelectArea}
                block
              >
                选择截屏区域
              </Button>
            )}
          </Space>
        </Card>

        {/* 预览画布 */}
        <Card className="preview-canvas" style={{ marginTop: 16 }}>
          <div className="canvas-header">
            <Title level={5}>实时预览</Title>
            <Space>
              <Button 
                icon={<RefreshCw size={18} />} 
                size="small"
                onClick={handleRefresh}
                disabled={!isCapturing}
              >
                刷新
              </Button>
              <Button 
                icon={<Download size={18} />} 
                size="small"
                onClick={handleSaveScreenshot}
                disabled={!currentScreenshot}
              >
                保存截图
              </Button>
            </Space>
          </div>
          <div
            ref={canvasRef}
            className="canvas-area"
            onMouseDown={handleMouseDown}
            onMouseMove={handleMouseMove}
            onMouseUp={handleMouseUp}
            onMouseLeave={handleMouseUp}
          >
            {!currentScreenshot ? (
              <div className="placeholder">
                <Monitor size={64} />
                <Text type="secondary">点击"开始识别"查看实时画面</Text>
              </div>
            ) : (
              <>
                <img 
                  src={currentScreenshot} 
                  alt="Screen capture" 
                  style={{ 
                    width: "100%", 
                    height: "100%", 
                    objectFit: "contain" 
                  }} 
                />
                {isCapturing && (
                  <div className="capturing-indicator">
                    <div className="pulse" />
                    <Text>正在捕获画面 ({fps} FPS)</Text>
                  </div>
                )}
              </>
            )}

            {/* 选区指示器 */}
            {captureArea && captureMode === "area" && (
              <div
                className="selection-box"
                style={{
                  left: captureArea.x,
                  top: captureArea.y,
                  width: Math.abs(captureArea.width),
                  height: Math.abs(captureArea.height),
                }}
              />
            )}
          </div>
        </Card>
      </motion.div>
    </div>
  );
};

export default ScreenCapture;
