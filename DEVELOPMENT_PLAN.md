# Game Partner Skill - 30 天开发计划

**项目周期**: 2026-01-28 ~ 2026-02-27 (30 天)  
**开发模式**: 单人全栈开发  
**工作量**: 假设每天 4-6 小时投入

---

## 📅 总体时间分配

| 阶段 | 周期 | 工作日 | 核心目标 |
|-----|------|--------|---------|
| **Week 1** | Day 1-7 | 环境搭建+基础架构 | Tauri 项目运行 + 截屏模块 |
| **Week 2** | Day 8-14 | 核心功能开发 | OCR + Wiki 爬虫 + 向量库 |
| **Week 3** | Day 15-21 | AI 集成 | RAG 流程 + LLM + TTS |
| **Week 4** | Day 22-28 | UI 完善+测试 | 弹幕系统 + Bug 修复 |
| **Buffer** | Day 29-30 | 缓冲时间 | 文档 + 演示准备 |

---

## Week 1: 环境搭建与基础架构 (Day 1-7)

### Day 1-2: 项目初始化 ⚙️

#### 目标
- [x] Tauri 项目脚手架搭建
- [x] 前后端开发环境配置
- [x] 基础 UI 框架搭建

#### 任务清单
```bash
# Day 1
□ 安装 Rust 工具链 (rustc 1.75+, cargo)
□ 安装 Node.js 20+ 和 pnpm
□ 创建 Tauri 项目
  - pnpm create tauri-app game-partner-skill
  - 选择: React + TypeScript + pnpm
□ 配置 Tauri 权限 (tauri.conf.json)
  - 允许截屏、文件系统访问
□ 配置 Tailwind CSS
□ 运行 Hello World

# Day 2
□ 设计基础 UI 布局
  - 顶部: 游戏识别状态栏
  - 中部: 弹幕/提示显示区
  - 底部: 控制面板 (开始/停止/设置)
□ 实现状态管理 (Zustand)
  - gameState: 当前游戏信息
  - assistantState: AI 状态
□ 实现 Tauri IPC 通信测试
  - 前端调用 Rust 函数示例
```

#### 交付物
- 可运行的 Tauri 应用窗口
- 基础 UI 框架
- IPC 通信验证通过

---

### Day 3-4: 截屏模块开发 📸

#### 目标
- [x] 实现稳定的截屏功能
- [x] 优化性能至目标帧率

#### 任务清单
```bash
# Day 3
□ 添加截屏依赖
  - Cargo.toml: screenshots = "0.6"
□ 实现截屏函数
  - src-tauri/src/screenshot.rs
  - 功能: capture_screen() -> Result<ImageBuffer>
□ 测试全屏截屏
  - 保存到临时文件验证
□ 实现窗口检测
  - 使用 windows-rs 获取活动窗口标题
  - 判断是否为游戏窗口

# Day 4
□ 添加定时截屏
  - ⚠️ 修改策略: 从 30fps 改为间隔模式
  - 配置: 1-15 秒可调,默认 3 秒
  - 理由: 降低 CPU 压力,AI 分析更友好
□ 实现截屏缓存
  - 使用 Arc<Mutex<ImageBuffer>> 共享最新帧
□ 性能优化
  - 仅在游戏窗口激活时截屏
  - 测试 CPU 占用 (目标 < 5%,优于原 10%)
  - 添加手动触发快捷键 (F12)
□ 前端展示截屏预览
  - Base64 编码传输
  - React 组件显示
  - 添加间隔时间滑块 (1-15s)
```

#### 交付物
- 可配置间隔截屏 (1-15s)
- CPU 占用 < 5%
- 前端实时预览
- 手动触发功能

---

### Day 5-7: 图像处理与 OCR 🔍

#### 目标
- [ ] 集成 OCR 引擎
- [ ] 提取关键游戏信息

#### 任务清单
```bash
# Day 5
□ 安装 Tesseract OCR
  - Windows: 下载安装包
  - 配置环境变量 TESSDATA_PREFIX
□ 添加 Rust 绑定
  - Cargo.toml: tesseract-rs = "0.1"
□ 实现基础 OCR
  - src-tauri/src/ocr.rs
  - 功能: extract_text(image) -> String
□ 测试中英文识别

# Day 6
□ 添加 OpenCV 依赖
  - 图像预处理: 灰度化、二值化、去噪
□ 实现 UI 区域裁剪
  - 定义常见 UI 位置 (任务栏、血条)
  - 裁剪后再 OCR (提升速度)
□ 关键词提取
  - 正则匹配: 任务名、地点、NPC 名
  - 构建游戏状态结构体 GameState

# Day 7
□ 集成截屏 + OCR 流程
  - 截屏 → 裁剪 → OCR → 解析
□ 性能测试
  - 端到端延迟 (目标 < 300ms)
□ 前端展示识别结果
  - 显示: "当前任务: XXX"
□ 代码重构与文档
```

#### 交付物
- 工作的 OCR 流程
- 识别延迟 < 300ms
- 提取游戏状态结构

---

## Week 2: 核心功能开发 (Day 8-14)

### Day 8-10: Wiki 爬虫与数据处理 🕷️

#### 目标
- [ ] 实现 Wiki 爬虫
- [ ] 构建文本处理流程

#### 任务清单
```bash
# Day 8
□ 选择目标游戏
  - 示例: 《艾尔登法环》Fandom Wiki
□ 添加爬虫依赖
  - scraper = "0.18"
  - reqwest (异步 HTTP)
□ 实现页面抓取
  - 获取 Wiki 目录页
  - 遍历所有条目链接
□ HTML 解析
  - 提取标题、段落、表格

# Day 9
□ 文本清洗
  - 移除 HTML 标签、广告、导航
  - 保留正文和关键数据
□ 文本分段
  - 按语义分段 (标题层级)
  - 或按 token 数 (512 tokens/段)
□ 数据持久化
  - 保存为 JSON Lines 格式
  - 文件: data/{game_name}/wiki_raw.jsonl

# Day 10
□ 批量爬取脚本
  - 并发控制 (避免被封)
  - 错误重试机制
□ 爬取 2 款游戏数据
  - 《艾尔登法环》
  - 《博德之门3》
□ 数据统计
  - 条目数、总字数、存储大小
```

#### 交付物
- 2 款游戏的 Wiki 数据
- 每游戏 ~3000-5000 条目
- JSON Lines 格式

---

### Day 11-14: 向量数据库搭建 🗄️

#### 目标
- [ ] 集成 Qdrant 向量库
- [ ] 生成并存储 Embeddings

#### 任务清单
```bash
# Day 11
□ 安装 Qdrant
  - 下载 Qdrant 二进制 (本地模式)
  - 或使用嵌入式 Rust 客户端
□ 添加依赖
  - qdrant-client = "1.7"
  - fastembed = "0.3"
□ 初始化 Qdrant
  - 创建集合: game_wiki
  - 向量维度: 384 (MiniLM-L6)

# Day 12
□ 下载嵌入模型
  - fastembed 自动下载 all-MiniLM-L6-v2
□ 实现 Embedding 生成
  - src-tauri/src/embeddings.rs
  - 功能: embed_text(text) -> Vec<f32>
□ 批量处理
  - 读取 wiki_raw.jsonl
  - 每条生成 embedding
  - 插入 Qdrant

# Day 13
□ 实现向量检索
  - 功能: search_wiki(query, top_k=5) -> Vec<WikiEntry>
□ 测试检索质量
  - 查询: "如何击败玛莉卡"
  - 验证返回内容相关性
□ 性能优化
  - 批量 embedding (提速)
  - 缓存常见查询

# Day 14
□ 元数据管理
  - SQLite 存储条目元信息
  - 表: wiki_entries (id, game, title, url)
□ 前端管理界面
  - 显示已索引游戏
  - 手动触发重新索引
□ Week 2 总结与演示
```

#### 交付物
- 可用的向量检索系统
- 检索延迟 < 100ms
- 相关性测试通过

---

## Week 3: AI 集成与语音交互 (Day 15-21)

### Day 15-17: RAG 流程与 LLM 集成 🤖

#### 目标
- [ ] 实现 RAG 提示生成
- [ ] 集成 LLM API

#### 任务清单
```bash
# Day 15
□ 设计 RAG 流程
  - 输入: GameState (OCR 结果)
  - 步骤: 向量检索 → Prompt 构建 → LLM 调用
□ 实现查询转换
  - 将游戏状态转为检索 query
  - 例: "任务: 击败玛莉卡" → "玛莉卡 攻略"
□ 构建 Prompt 模板
  - 系统 Prompt: 定义助手角色
  - 用户 Prompt: 嵌入检索内容

# Day 16
□ 集成 OpenAI API
  - 使用 reqwest 发送请求
  - 模型: gpt-4o-mini
  - 配置: temperature=0.7, max_tokens=100
□ 实现调用函数
  - src-tauri/src/llm.rs
  - 功能: generate_tip(game_state, context) -> String
□ 错误处理
  - API 限流、超时重试
  - Fallback: 返回检索内容摘要

# Day 17
□ 可选: 本地 LLM 集成
  - 使用 llama.cpp Rust 绑定
  - 模型: Llama 3.2 3B (量化版)
  - 推理测试 (速度 vs 质量)
□ 前端展示 AI 提示
  - 半透明浮窗
  - 可拖动、可关闭
□ 测试完整流程
  - 截屏 → OCR → 检索 → LLM → 显示
```

#### 交付物
- 工作的 RAG 提示生成
- LLM 调用延迟 < 3s
- 提示质量人工验证

---

### Day 18-21: TTS 与语音交互 🔊

#### 目标
- [ ] 实现文字转语音
- [ ] (可选) 语音唤醒

#### 任务清单
```bash
# Day 18
□ 添加 TTS 依赖
  - tts = "0.26"
□ 实现基础 TTS
  - src-tauri/src/tts.rs
  - 功能: speak(text) -> Result<()>
  - Windows: 使用 SAPI 5
□ 测试语音播报
  - 朗读 AI 生成的提示
  - 调整语速、音量

# Day 19
□ TTS 配置界面
  - 前端: 选择音色 (男/女)
  - 前端: 调整语速滑块
  - 保存到本地配置
□ 异步播报
  - 不阻塞主线程
  - 队列管理 (防止重叠)
□ 测试播报延迟
  - 目标: < 300ms

# Day 20
□ (可选) 语音唤醒
  - 添加 Vosk 依赖
  - 实现麦克风监听
  - 唤醒词检测: "小助手"
  - 触发主动提示
□ 或替代: 快捷键唤醒
  - 全局热键: Ctrl+Shift+G

# Day 21
□ 集成测试
  - 完整流程: 游戏触发 → AI 提示 → 语音播报
□ 性能优化
  - TTS 预加载
  - 音频缓存
□ Week 3 总结
```

#### 交付物
- 流畅的语音播报
- 延迟 < 500ms
- 配置界面可用

---

## Week 4: UI 完善与测试 (Day 22-28)

### Day 22-24: 弹幕与互动系统 🎉

#### 目标
- [ ] 实现弹幕效果
- [ ] 添加送礼动画

#### 任务清单
```bash
# Day 22
□ 弹幕 UI 组件
  - 使用 framer-motion 实现滚动动画
  - 样式: 半透明、彩色文字
□ 弹幕生成逻辑
  - 触发条件: 死亡、胜利、新区域
  - 内容: AI 生成鼓励/吐槽
  - 示例: "加油!这个 Boss 很简单!"
□ 弹幕配置
  - 开关、速度、密度

# Day 23
□ 送礼动画
  - 预设礼物: 🚀火箭、🌹鲜花、666
  - 触发: Boss 战胜利
  - 动画: Lottie 或 CSS 动画
□ 音效
  - 弹幕出现声音
  - 礼物音效
  - 音量控制

# Day 24
□ 互动层完善
  - 状态栏: 显示识别的游戏
  - 任务追踪: 当前任务/位置
  - AI 状态: 思考中/空闲
□ UI 抛光
  - 响应式布局
  - 暗色主题
  - 图标库 (lucide-react)
```

#### 交付物
- 弹幕系统运行流畅
- 送礼动画效果好
- UI 美观易用

---

### Day 25-26: 测试与 Bug 修复 🐛

#### 目标
- [ ] 全功能集成测试
- [ ] 修复关键 Bug

#### 任务清单
```bash
# Day 25
□ 功能测试清单
  - [x] 截屏稳定性 (长时间运行)
  - [x] OCR 准确率 (多场景)
  - [x] 向量检索相关性
  - [x] LLM 提示质量
  - [x] TTS 播报清晰度
  - [x] 弹幕/礼物触发正确
□ 性能测试
  - CPU 占用曲线
  - 内存泄漏检测
  - 响应时间统计

# Day 26
□ Bug 修复
  - 截屏崩溃 (特定分辨率)
  - OCR 卡死 (异常字符)
  - 向量库锁死 (并发问题)
  - UI 渲染抖动
□ 代码审查
  - 移除调试代码
  - 优化错误日志
  - 添加注释
```

#### 交付物
- 无严重 Bug
- 性能达标
- 代码质量良好

---

### Day 27-28: 文档与演示准备 📝

#### 目标
- [ ] 完善项目文档
- [ ] 录制演示视频

#### 任务清单
```bash
# Day 27
□ 用户手册
  - 安装指南
  - 快速开始
  - 功能说明
  - 常见问题
□ 开发者文档
  - 架构说明
  - API 文档
  - 贡献指南
□ README 更新
  - 添加截图/GIF
  - 功能清单
  - 技术栈说明

# Day 28
□ 演示准备
  - 选择演示游戏 (艾尔登法环)
  - 设计演示场景:
    1. 启动应用
    2. 识别游戏
    3. 触发 AI 提示
    4. 语音播报
    5. 弹幕/礼物
□ 录制视频
  - 使用 OBS Studio
  - 时长: 3-5 分钟
  - 添加字幕说明
□ 发布准备
  - 打包 Tauri 应用 (.exe)
  - 压缩发布包
  - 准备 GitHub Release
```

#### 交付物
- 完整文档
- 演示视频
- 可分发安装包

---

## Day 29-30: 缓冲与优化 ⏳

### 目标
- [ ] 处理遗留问题
- [ ] 准备下一阶段

#### 任务清单
```bash
□ 遗留 Bug 修复
□ 性能微调
□ 用户反馈收集准备
□ 下阶段规划
  - 支持更多游戏
  - 云端同步
  - 社区功能
□ 代码归档
  - Git 提交整理
  - Tag 版本: v0.1.0-mvp
```

---

## 📊 里程碑检查点

| 检查点 | 日期 | 验收标准 |
|-------|------|---------|
| **M1: 基础架构** | Day 7 | Tauri 运行 + 截屏 + OCR |
| **M2: 知识库** | Day 14 | 向量库检索可用 |
| **M3: AI 集成** | Day 21 | RAG + TTS 工作 |
| **M4: MVP 完成** | Day 28 | 完整演示可运行 |

---

## 🚨 风险缓解计划

### 高风险项

1. **OCR 识别率不达标**
   - Plan B: 降低识别精度要求,依赖关键词模糊匹配
   - Plan C: 用户手动输入游戏状态

2. **30 天时间不足**
   - 裁剪功能: 暂缓语音唤醒、送礼动画
   - 减少游戏支持: 仅 1 款游戏 Demo

3. **LLM 调用成本**
   - 使用免费 API (如 Groq)
   - 或完全本地化 (Llama 3.2)

### 每日时间分配建议

```
工作日 (周一~周五):
- 晚上: 3 小时编码
- 周末: 8 小时全天开发

总计: 5*3 + 2*8 = 31 小时/周
30 天总投入: ~120 小时
```

---

## ✅ 成功标准

### MVP 必须满足:
- [x] 能够识别至少 1 款游戏
- [x] RAG 提示生成成功率 > 70%
- [x] TTS 播报流畅
- [x] 端到端延迟 < 5s
- [x] 应用稳定运行 > 30 分钟无崩溃
- [x] 有完整的演示视频

---

## 📞 每周同步

建议每周末进行自我回顾:
- ✅ 本周完成了什么?
- ⚠️ 遇到什么阻塞?
- 📅 下周计划调整?

---

**计划状态**: ✅ 已制定  
**负责人**: Rust/React-TS 开发者  
**开始日期**: 2026-01-28  
**目标交付**: 2026-02-27

🎯 Let's build something amazing! 加油!
